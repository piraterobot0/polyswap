#!/usr/bin/env python3
"""
ERC-20 Token Generator
Generate customized ERC-20 token contracts with various features
"""

import sys
import os
import json
import click
from pathlib import Path
from datetime import datetime

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

# Token templates
TEMPLATES = {
    'basic': {
        'name': 'Basic ERC-20',
        'description': 'Simple token with fixed supply',
        'file': 'contracts/standards/erc20/BasicERC20.sol',
        'features': ['Fixed Supply', 'No Owner Functions']
    },
    'mintable': {
        'name': 'Mintable ERC-20',
        'description': 'Token with minting capability',
        'file': 'contracts/standards/erc20/MintableERC20.sol',
        'features': ['Mintable', 'Ownable', 'Variable Supply']
    },
    'burnable': {
        'name': 'Burnable ERC-20',
        'description': 'Token with burn capability',
        'file': 'contracts/standards/erc20/BurnableERC20.sol',
        'features': ['Burnable', 'Deflationary', 'Fixed Initial Supply']
    },
    'pausable': {
        'name': 'Pausable ERC-20',
        'description': 'Token with pause/unpause functionality',
        'file': 'contracts/standards/erc20/PausableERC20.sol',
        'features': ['Pausable', 'Ownable', 'Emergency Stop']
    },
    'advanced': {
        'name': 'Advanced ERC-20',
        'description': 'Token with all features combined',
        'file': None,  # Will be generated
        'features': ['Mintable', 'Burnable', 'Pausable', 'Ownable', 'Capped Supply']
    }
}

def generate_advanced_template(name: str, symbol: str, decimals: int, cap: int = 0) -> str:
    """Generate advanced ERC-20 contract with all features"""
    
    cap_code = f"""
    uint256 public immutable cap;
    
    modifier checkCap(uint256 amount) {{
        if (cap > 0) {{
            require(totalSupply() + amount <= cap, "ERC20Capped: cap exceeded");
        }}
        _;
    }}""" if cap > 0 else ""
    
    cap_constructor = f"""
        cap = {cap} * 10**uint256(_decimals);""" if cap > 0 else ""
    
    cap_modifier = " checkCap(amount)" if cap > 0 else ""
    
    return f"""// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title {name}
 * @dev Advanced ERC20 Token with mint, burn, pause, and cap features
 * Generated by ERC20 Token Generator
 */
contract {symbol}Token {{
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;
    string public name = "{name}";
    string public symbol = "{symbol}";
    uint8 public decimals = {decimals};
    address public owner;
    bool public paused;{cap_code}
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Paused(address account);
    event Unpaused(address account);
    event Mint(address indexed to, uint256 amount);
    event Burn(address indexed from, uint256 value);

    modifier onlyOwner() {{
        require(owner == msg.sender, "Ownable: caller is not the owner");
        _;
    }}

    modifier whenNotPaused() {{
        require(!paused, "Pausable: paused");
        _;
    }}

    modifier whenPaused() {{
        require(paused, "Pausable: not paused");
        _;
    }}

    constructor(uint256 _initialSupply) {{
        owner = msg.sender;
        paused = false;{cap_constructor}
        
        if (_initialSupply > 0) {{
            _mint(msg.sender, _initialSupply * 10**uint256(decimals));
        }}
    }}

    function totalSupply() public view returns (uint256) {{
        return _totalSupply;
    }}

    function balanceOf(address account) public view returns (uint256) {{
        return _balances[account];
    }}

    function transfer(address to, uint256 amount) public whenNotPaused returns (bool) {{
        address owner = msg.sender;
        _transfer(owner, to, amount);
        return true;
    }}

    function allowance(address owner, address spender) public view returns (uint256) {{
        return _allowances[owner][spender];
    }}

    function approve(address spender, uint256 amount) public whenNotPaused returns (bool) {{
        address owner = msg.sender;
        _approve(owner, spender, amount);
        return true;
    }}

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public whenNotPaused returns (bool) {{
        address spender = msg.sender;
        _spendAllowance(from, spender, amount);
        _transfer(from, to, amount);
        return true;
    }}

    // Mint new tokens
    function mint(address to, uint256 amount) public onlyOwner{cap_modifier} {{
        _mint(to, amount);
    }}

    // Burn tokens
    function burn(uint256 amount) public {{
        _burn(msg.sender, amount);
    }}

    function burnFrom(address account, uint256 amount) public {{
        _spendAllowance(account, msg.sender, amount);
        _burn(account, amount);
    }}

    // Pause token transfers
    function pause() public onlyOwner whenNotPaused {{
        paused = true;
        emit Paused(msg.sender);
    }}

    function unpause() public onlyOwner whenPaused {{
        paused = false;
        emit Unpaused(msg.sender);
    }}

    // Transfer ownership
    function transferOwnership(address newOwner) public onlyOwner {{
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        address oldOwner = owner;
        owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }}

    function renounceOwnership() public onlyOwner {{
        address oldOwner = owner;
        owner = address(0);
        emit OwnershipTransferred(oldOwner, address(0));
    }}

    // Internal functions
    function _mint(address account, uint256 amount) internal {{
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply += amount;
        unchecked {{
            _balances[account] += amount;
        }}
        emit Transfer(address(0), account, amount);
        emit Mint(account, amount);
    }}

    function _burn(address account, uint256 amount) internal {{
        require(account != address(0), "ERC20: burn from the zero address");

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {{
            _balances[account] = accountBalance - amount;
            _totalSupply -= amount;
        }}

        emit Transfer(account, address(0), amount);
        emit Burn(account, amount);
    }}

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal {{
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
        unchecked {{
            _balances[from] = fromBalance - amount;
            _balances[to] += amount;
        }}

        emit Transfer(from, to, amount);
    }}

    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal {{
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }}

    function _spendAllowance(
        address owner,
        address spender,
        uint256 amount
    ) internal {{
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {{
            require(currentAllowance >= amount, "ERC20: insufficient allowance");
            unchecked {{
                _approve(owner, spender, currentAllowance - amount);
            }}
        }}
    }}
}}"""

@click.command()
@click.option('--template', type=click.Choice(['basic', 'mintable', 'burnable', 'pausable', 'advanced']), 
              prompt='Select token template', help='Token template to use')
@click.option('--name', prompt='Token name', help='Name of the token')
@click.option('--symbol', prompt='Token symbol', help='Symbol of the token')
@click.option('--decimals', default=18, prompt='Token decimals', help='Number of decimals')
@click.option('--supply', default=1000000, prompt='Initial supply', help='Initial token supply')
@click.option('--cap', default=0, help='Maximum supply cap (0 = no cap, advanced template only)')
@click.option('--output', help='Output directory (default: contracts/generated/)')
def generate_token(template, name, symbol, decimals, supply, cap, output):
    """Generate an ERC-20 token contract"""
    
    print("\n" + "="*60)
    print("🪙 ERC-20 TOKEN GENERATOR")
    print("="*60)
    
    # Display template info
    template_info = TEMPLATES[template]
    print(f"\n📋 Template: {template_info['name']}")
    print(f"   {template_info['description']}")
    print(f"   Features: {', '.join(template_info['features'])}")
    
    print(f"\n🔧 Token Configuration:")
    print(f"   Name: {name}")
    print(f"   Symbol: {symbol}")
    print(f"   Decimals: {decimals}")
    print(f"   Initial Supply: {supply:,}")
    if template == 'advanced' and cap > 0:
        print(f"   Max Supply Cap: {cap:,}")
    
    # Set output directory
    if not output:
        output = 'contracts/generated'
    os.makedirs(output, exist_ok=True)
    
    # Generate filename
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"{symbol}Token_{template}_{timestamp}.sol"
    filepath = os.path.join(output, filename)
    
    # Get or generate contract code
    if template == 'advanced':
        # Generate custom advanced contract
        contract_code = generate_advanced_template(name, symbol, decimals, cap)
    else:
        # Read template file
        template_path = template_info['file']
        with open(template_path, 'r') as f:
            contract_code = f.read()
        
        # Replace placeholders if needed
        # (The templates are already parameterized via constructor)
    
    # Save contract
    with open(filepath, 'w') as f:
        f.write(contract_code)
    
    print(f"\n✅ Token contract generated!")
    print(f"   File: {filepath}")
    
    # Generate deployment parameters
    deploy_params = {
        'contract_name': f"{symbol}Token" if template == 'advanced' else template_info['file'].split('/')[-1].replace('.sol', ''),
        'constructor_args': {
            'name': name,
            'symbol': symbol,
            'decimals': decimals,
            'initialSupply': supply
        },
        'template': template,
        'features': template_info['features'],
        'generated_at': datetime.now().isoformat()
    }
    
    if template == 'advanced':
        deploy_params['constructor_args'] = {'initialSupply': supply}
        if cap > 0:
            deploy_params['cap'] = cap
    
    # Save deployment parameters
    params_file = filepath.replace('.sol', '_params.json')
    with open(params_file, 'w') as f:
        json.dump(deploy_params, f, indent=2)
    
    print(f"   Params: {params_file}")
    
    # Show next steps
    print(f"\n📝 Next Steps:")
    print(f"1. Review the generated contract: {filepath}")
    print(f"2. Compile: python scripts/compile/compile_sol.py {filepath}")
    print(f"3. Deploy: python scripts/deploy/deploy_generated.py {params_file}")
    
    print("\n⚠️  Remember to:")
    print("   - Review the contract code before deployment")
    print("   - Test on testnet first")
    print("   - Audit the contract for production use")
    
    print("\n" + "="*60)

if __name__ == '__main__':
    # Create directories if they don't exist
    os.makedirs('scripts/generate', exist_ok=True)
    os.makedirs('contracts/generated', exist_ok=True)
    
    generate_token()